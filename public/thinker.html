<head>
	<link rel="stylesheet" type="text/css" href="chess.css">

	<script src="jquery.js"></script>
	<script src="angular.js"></script>
	<script src="brandNewAi.js"></script>
	<script src="engine.js"></script>

	<script>
		
	

	var appModule = angular.module("appModule", []);

	function ApplicationController($rootScope, $http, $interval, $timeout, $rootScope) {
		
		function learnerLooped(pastTables){
			var x = countInArray(pastTables[pastTables.length-1],pastTables)
			var y = countInArray(pastTables[pastTables.length-2],pastTables)
			
			if(x==3||y==3){return true}else{return false}
		//	
		}
		
		var evaledGame=function(data){
		
			// console.log(data)
				var moves=data.moves
			
			$http.get('aiOn?t='+data.tableNum)
			
			var myGame=new Dbtable(data.tableNum,data.wName,data.bName)
			
			moves.forEach(function(moveFromDb){
			
				var moveStr=moveFromDb.slice(2,6)		//levagni a kepeket...	(mi ut mit)
			//////////////////////
							///replace this!!!
				var toPush =  getPushString(myGame.table,moveStr)//piece

				+new String(new Date().getTime())

				// if(!(toPush==myGame.moves[myGame.moves.length-1])){
				myGame.moves.push(toPush)

				myGame.table = moveIt(moveStr, myGame.table)			//	<----moves it
				
				//$rootScope.showTable(myGame.table)

				myGame.wNext = !myGame.wNext

				myGame.pollNum++

				//myGame.moved = new Date().getTime()

				myGame.table = addMovesToTable(myGame.table, myGame.wNext, true)	//true stands for pawn and king only: allpasttables only

				//remember this state for 3fold rule
				var sendThis=createState(myGame.table)
				
				
				myGame.allPastTables.push(sendThis)

				//$rootScope.whatToDo = 'idle'
			
				//$rootScope.sendMessage('move '+moveStr+' processed.')
			
			/////////////////////////
			
			
			})
			evalGame(myGame,true)	//true should only!!!!tells it was learnergame
			
			
			if (learnerLooped(myGame.allPastTables)) myGame.isDraw=true
			
			$rootScope.sendMessage('table '+myGame.tableNum+' processed. (eval)')
			
			return myGame
			
		}
		
		
		
		$rootScope.mySpeed=60000/(ai(new Dbtable(1,'a','b').table,true,[])[0][2])
		
		///////
		$rootScope.pollOn=true
		$rootScope.messages = ["Starting..."]
	var succeeded=0	
	$rootScope.refreshWhenUp = function() {
		
		$http.get('/forceStop?t=' + $rootScope.tableNum)
			.then(function(response) {
				$rootScope.setCookies()
				succeeded++
				//$rootScope.sendMessage('connection came back, will restart soon..')
				$rootScope.receivedMessage='restart in 10s'
				if(succeeded>3){	//server must be running
					window.location.reload(true); //$rootScope.sendMessage('looped, forceStop sent')
				}else{
					
					$timeout($rootScope.refreshWhenUp(), 3000)
				}
				
				
			}, function(data) {
				 $rootScope.receivedMessage='connection error, 3s retry'
				 succeeded=0
				$timeout($rootScope.refreshWhenUp(), 3000)
			})
	}
	
	function moveInTable(moveStr,dbTable){
		
		var toPush =  getPushString(dbTable.table,moveStr)//piece

				+new String(new Date().getTime())

				// if(!(toPush==$rootScope.moves[$rootScope.moves.length-1])){
				
				
				dbTable.moves.push(toPush)

				dbTable.table = moveIt(moveStr, dbTable.table)			//	<----moves it
				
				//$rootScope.showTable($rootScope.table)

				dbTable.wNext = !dbTable.wNext

				dbTable.pollNum++

				//$rootScope.moved = new Date().getTime()
				
				dbTable.table = addMovesToTable(dbTable.table, dbTable.wNext)	//true stands for pawn and king only: allpasttables only

				//remember this state for 3fold rule
				var sendThis=createState(dbTable.table)
				
				
				dbTable.allPastTables.push(sendThis)

				//$rootScope.whatToDo = 'idle'
			
				//$rootScope.sendMessage('move '+moveStr+' processed.')
			
			/////////////////////////
			
			
			//})
			evalGame(dbTable,true)	//true should tell it was learnergame, not yet
			
			
			
			return dbTable
			
			
		
	}
	
	function dbAi(dbTable){
		
		 var retMove=ai(dbTable.table,dbTable.wNext,dbTable.allPastTables)
					 
					 	var moveStr=""
						 if(retMove.length>1)moveStr=retMove[1][0]
						
		
		dbTable=moveInTable(moveStr,dbTable)		
			
			
			// $http.post('/moved',dbTable,function(req,res){
				
			// })
			
		
		return dbTable
		
		
		
		
		
		
		
	}
	function processMove(move){
		
		//var result=[]
		
		///////////////////////////////////////
		var cfTable=move.cfTable
		var cfMoveCoords=move.moceCoords
		var moveIndex=move.moveIndex
		
		var cfColor=move.cfColor
		
		var stepMove=move.stepMove
		
		
		//var d
		
		
		
		
		
			//cfMoves.forEach(function(stepMove, moveIndex) {
		
		//process.stdout.write(".");
		
		var smallValScore=(10-cfTable[cfMoveCoords[moveIndex][0]][cfMoveCoords[moveIndex][1]][1])/1000

		//vonjuk ki ha vedett
		// if (cfTable[cfMoveCoords[moveIndex][2]][cfMoveCoords[moveIndex][3]][6]){			//ha vedett 
		// 	fHitValue-=cfTable[cfMoveCoords[moveIndex][0]][cfMoveCoords[moveIndex][1]][1]/10000	//kivonja amivel lep
		// }
		
		var fwdVal = 0
		if(!cfColor&&cfTable[cfMoveCoords[moveIndex][0]][cfMoveCoords[moveIndex][1]][1]==1) {	//ha fekete parejt tol
			fwdVal=(7-stepMove[1])*0.01			
		}
		if(cfColor&&cfTable[cfMoveCoords[moveIndex][0]][cfMoveCoords[moveIndex][1]][1]==1) {	//ha feher parejt tol
			fwdVal=(stepMove[1]-2)*0.01			
		}
		
		//fHitValue = cfTable[cfMoveCoords[moveIndex][2]][cfMoveCoords[moveIndex][3]][1] //leutott babu erteke, vagy 0
		
		var tempTable = moveIt(stepMove, cfTable, true, fHitValue) //, false, hitValue)
		protectTable(tempTable)
		
		
		var loopValue = 0 //=(fHitValue-retHitValue)*10
		var loopedValue = 0 //=(fHitValue-retHitValue)*10
		
		var forceLoopValue=0
		////
		//indul a noloop
		
		tempTable= addMovesToTable(tempTable,!cfColor)
		
		var thisTState= createState(tempTable)
		var counted=countInArray(thisTState ,allPast)
		if(counted >1){
			//3szorra lepnenk ugyanabba a statuszba
			//ideiglenesen ne
			//console.log ('i could 3fold '+counted)
			
			
			
			if(dontLoop) loopedValue-=1000
			
			
			
			if(counted >3){
				//surely looped
				looped=true
				
			}
			
		}else{
			// console.log (counted)
			// console.log(thisTState)
		}
						




		
		////
		
		var cfRetMoves = []
		var cfRetMoveCoords = []
		//ide is full getallmoves kene, de vhogy tudnunk kell hany lepest szedett le sakk miatt, es azt is ebbol hanyszor lep a kirallyal..
		getAllMoves(tempTable, !cfColor).forEach(function(thisMove) { //get all his moves in array of strings
			cfRetMoves.push(dletters[thisMove[0]] + (thisMove[1] + 1) + dletters[thisMove[2]] + (1 + thisMove[3]))
			cfRetMoveCoords.push(thisMove)

		})
		var origLen = cfRetMoves.length
		var removeCount = 0
		for(var i = cfRetMoves.length - 1; i >= 0; i--) { //sakkba nem lephet o sem
			if(captured(moveIt(cfRetMoves[i], tempTable), !cfColor)) { //sakkba lepne valaszkent	//moveit retmove ittis ottis
				if(tempTable[cfRetMoveCoords[i][0]][cfRetMoveCoords[i][1]][1]==9){
					removeCount++			//fogja a kiraly koruli mezoket
				}else{
					removeCount+=3			//ollo ha sakkba lepne de nem kirallyal lepett
				}
				cfRetMoves.splice(i, 1)
				cfRetMoveCoords.splice(i, 1)
				
				// if(!(tempTable[cfRetMoveCoords[i][0]][cfRetMoveCoords[i][1]][1]==9)){
					
				// }
			}
		}
		var captureScore = 0
		if(origLen == 0) { //not do devide by zero also mark won?
			//pattot adne?
		} else {
			captureScore = parseInt(removeCount * 100 / origLen) / 10000
		}

		var retTable = []
		
		var hhit = 0 //(origHisHitValue-rtnHisHitValue)
		var mhit = 0 //(rtnMyHitValue-origMyHitValue)*10
		var dontGetHit=0
		var lsancValue=0
		var rsancValue=0
		var sancValue=0
		var getToMiddle=0
		var pushHimBack=0
		var mostMoved=0
		

		var rtnValue=0 //=loopValue+mhit+hhit

		if(cfRetMoves.length == 0) {

			if(captured(tempTable, !cfColor)) {
				loopValue += 10000 //ott a matt
			} else {

				//pattot adna
				loopValue -= 10000//ideiglenesen ne adjunk pattot sosem!!
			}

			//retTable = cfTable //vmit vissza kell azert adni..., legyen az eredeti         
			retProtect = origProtect
			retData = origData
			retTable = cfTable
			hisBestRtnMove = "stuck."
			var retHitValue = [0]

		} else {

			//lesz valaszlepese

			var retData = []
			var tempRetValue = -9999990
			var retHitValue //= //[0]
			var retProtect=0
			

			cfRetMoves.forEach(function(stepRetMove, retMoveIndex) {
				
				var tretHitValue = [0]//tempTable[cfRetMoveCoords[retMoveIndex][2]][cfRetMoveCoords[retMoveIndex][3]][1] 
				var eztVondKi=0
				
						
				//kesobb vonjuk ki ha vedett
				if (tempTable[cfRetMoveCoords[retMoveIndex][2]][cfRetMoveCoords[retMoveIndex][3]][6]){			//ha vedett 
					eztVondKi=tempTable[cfRetMoveCoords[retMoveIndex][0]][cfRetMoveCoords[retMoveIndex][1]][1] 	//kivonja amivel lep
				}
				
				//how abot en pass????//kivonni kesobb a leutott babu erteke, vagy 0

				var tempRetTable = moveIt(stepRetMove, tempTable, true ,tretHitValue) //, false, hitValue)
				
				////
				//indul a noloop
				
				tempRetTable= addMovesToTable(tempRetTable,cfColor)
				
				if(countInArray(createState(tempRetTable) ,allPast) >1){
					//3szorra lephetne ugyanabba a statuszba
					//ideiglenesen ne
					if (dontLoop){
						 loopedValue-=100
					}else{
						forceLoopValue+=0.5		
					}
					
					looped=true
					//console.log('he could 3fold')
				}
								
		
		
		
		
				
				////
			
				
				
				
				//vonjuk ki ha vedett
				if(eztVondKi>0){
					tretHitValue[0]-=eztVondKi
					
				}
				var tretProtect= (protectTable(tempRetTable, cfColor) - origProtect)/1000 //majd kesobb
				
				if(captured(tempRetTable,cfColor)){
					dontGetHit-=.001
					//var myTempMoves=getAllMoves(tempRetTable,cfColor,false,0)
					if(!canIMove(tempRetTable,cfColor)){
						dontGetHit=-10000					//ha mattot tudna adni erre a lepesre, akkor meg ne lepjuk!
					}
				}
				
				var tempRetData = getTableData(tempRetTable, cfColor)

				//var tretTableValue = tempRetData[0] //tablevalue-t nem is kene szamolni, megvan a retHitValue		//talan az sem kell
				var tretMyHitValue = tempRetData[1]
				var tretHisHitValue = tempRetData[2]
				// var tretlSanc = tempRetData[3]
				// var tretrSanc = tempRetData[4]
				

				if((tretHitValue[0]) * 10 - tretMyHitValue * 10 + tretHisHitValue > tempRetValue) {

					tempRetValue = (tretHitValue[0]) * 10 - tretMyHitValue * 10 + tretHisHitValue 
					
					retProtect = tretProtect
					retData = tempRetData
					retTable = tempRetTable
					hisBestRtnMove = stepRetMove
					retHitValue = tretHitValue
					//retTableValue=tempRetTable
				}else{
					if((fHitValue[0]-tretHitValue[0]) * 10 - tretMyHitValue * 10 + tretHisHitValue == tempRetValue){
						hisBestRtnMove = hisBestRtnMove+'.'//+stepRetMove//"many"
					}
				}

			})

			var rtnTableValue = retData[0]
			var rtnMyHitValue = retData[1]
			var rtnHisHitValue = retData[2]
			var rtnlSanc= retData[3]
			var rtnrSanc= retData[4]
			var rtnGetToMiddle=retData[5]
			var rtnPushHimBack=retData[6]
			var rtnMostMoved=retData[7]
			
			

			loopValue += (fHitValue[0]-retHitValue[0])*10 			//(rtnTableValue - origTableValue) * 10
			hhit = (origHisHitValue - rtnHisHitValue)
			mhit = (rtnMyHitValue - origMyHitValue) * 10
			lsancValue=(rtnlSanc- origlSanc)/100
			rsancValue=(rtnrSanc- origrSanc)/100
			getToMiddle=(rtnGetToMiddle-origGetToMiddle)/1000
			pushHimBack=(rtnPushHimBack-origPushHimBack)/1000		//this could be somevhere between 100&1000
			
			mostMoved=(origMostMoved-rtnMostMoved)/2			//temp high, we should lover this as the game goes on //will be -.5 or 0 always
			if(mostMoved>0)mostMoved=0		//it is positive when our most moved piece goes off
			
					//rtnPushHimBack-
			

			//rtnValue = loopValue + mhit + hhit + retProtect//my hit matters most as i'm next
			
			if(cfColor){
				if((stepMove=='e1g1'&&cfTable[5][1][0]==2&&cfTable[6][1][0]==2&&cfTable[7][1][0]==2)	//vegig covered
					||
					(stepMove=='e1c1'&&cfTable[0][1][0]==2&&cfTable[1][1][0]==2&&cfTable[2][1][0]==2))sancValue+=.35	//sancoljon ha jol esik
				
			}else{
				if((stepMove=='e8g8'&&cfTable[5][6][0]==1&&cfTable[6][6][0]==1&&cfTable[7][6][0]==1)
					||
					(stepMove=='e8c8'&&cfTable[0][6][0]==1&&cfTable[1][6][0]==1&&cfTable[2][6][0]==1))sancValue+=.35	//sancoljon ha jol esik
				
			}
				
		}

		//rtnValue += fwdVal

		//	

		var tTable2Value = 0

		if(false) {			//temp?
			//
			
			var cf2Moves = []
			var cf2MoveCoords = []
		
			getAllMoves(retTable, cfColor).forEach(function(thisMove) { //get all my moves in array of strings
				cf2Moves.push(dletters[thisMove[0]] + (thisMove[1] + 1) + dletters[thisMove[2]] + (1 + thisMove[3]))
				cf2MoveCoords.push(thisMove)
			})
		
			// es akkor nem kell ez:
			for(var i = cf2Moves.length - 1; i >= 0; i--) { //sakkba nem lephetunk			
				if(captured(moveIt(cf2Moves[i], retTable), cfColor)) { //sakkba lepnenk					<---  merge this
					cf2Moves.splice(i, 1)
					cf2MoveCoords.splice(i, 1)					//ez is lehetne count:ranking, minus!!
					tTable2Value-=0.0001
				}
			}
			
			//check there's a win:
			var potentMoves=[]	//will make an array of potential winning moves
			var potentTables=[]	//and resulting tables
														//							
			for(var i = cf2Moves.length - 1; i >= 0; i--) {	
				
				var potentTable=moveIt(cf2Moves[i], retTable)
				
				if(captured(potentTable, !cfColor)) { 				//az lehet potent, ahol sakkot adok
					
					//make a ranker here
																			//							<---	with this
			
					tTable2Value+=0.00001			//ket lepesben sakkot ad(hat)ok
					potentMoves.push(cf2Moves[i])
					potentTables.push(potentTable)
					//cfMoveCoords.splice(i, 1)					//ez is lehetne count:ranking
				}
			}
			
			
			//check if capturing moves are winners:
			
			var twoStepWinners=[]
			
			potentMoves.forEach(function(potentMove,potentMoveCount){
				var potentTable=potentTables[potentMoveCount]			//potent tablan mindenkepp sakkban all remember
				////
				
				var ret2potMoves = []
				//var ret2potMoveCoords = []
		
				getAllMoves(potentTable, !cfColor).forEach(function(thisMove) { //get all his moves in array of strings
					ret2potMoves.push(dletters[thisMove[0]] + (thisMove[1] + 1) + dletters[thisMove[2]] + (1 + thisMove[3]))
					//ret2potMoveCoords.push(thisMove)
		
				})
				//var origLen = ret2potMoves.length
				//var removeCount = 0
				for(var i = ret2potMoves.length - 1; i >= 0; i--) { //sakkba nem lephet o sem
					if(captured(moveIt(ret2potMoves[i], potentTable), !cfColor)) { //sakkba lepne valaszkent	//moveit retmove ittis ottis
						ret2potMoves.splice(i, 1)
						//ret2potMoveCoords.splice(i, 1)
						//removeCount++
						tTable2Value+=0.000001			//sakkba lephetne
						
					}
				}
				//
				if (ret2potMoves.length==0){
					//mattot tudok adni a legjobbnak tuno lepesere
					//process.stdout.write("!");
		//console.log('2 lepesbol mattolhatok')
					if(tTable2Value<5)tTable2Value+=5
					
						//meg kene nezni ki tud-e lepni belole
						
						
					tTable2Value+=0.00001			//sakkba lephetne
				}
				
				////
			})
			
			///

		}
		// lsancValue*=10
		// rsancValue*=10
		
		///modType 'l' is loopval *=-1
		
		//if(modType=="lpV")loopValue*= modConst
		
		//console.log(modType)
		switch(modType){
			case undefined:
			
			break;
			
			case "lpV":
				
				loopValue*= modConst
			
			break;
			
			case "cpt":
			
				captureScore*= modConst
				
			break;
			
			case "tt2":
			
				tTable2Value*= modConst
				
			break;
			
			case "sVS":
			
				smallValScore*= modConst
				
			break;
			
			
			case "dGH":
			
				dontGetHit*= modConst
				
			break;
			
			
			case "rPr":
			
				retProtect*= modConst
				
			break;
			
			
			case "mht":
			
				mhit*= modConst
				
			break;
			
			
			case "hht":
			
				hhit*= modConst
				
			break;
			
			case "mMv":
			
				mostMoved*= modConst
				
			break;
			
			case "pHB":
			
				pushHimBack*= modConst
				
			break;
			
			case "gTM":
			
				getToMiddle*= modConst
				
			break;
			
			case "fwV":
			
				fwdVal*= modConst
				
			break;
			
			case "scV":
			
							lsancValue*= modConst
							rsancValue*= modConst
							sancValue*= modConst
				
			break;
			
			
			
			
		}
		
		
		
		var pushThisValue = 
		
							tTable2Value + 
							loopValue + 
							captureScore + //fHitValue +
							smallValScore+
							dontGetHit+
							retProtect+
							mhit+
							hhit+
							fwdVal+
							lsancValue+
							rsancValue+
							sancValue+
							getToMiddle+
							pushHimBack+
							mostMoved+
							loopedValue+
							forceLoopValue

		move.score=pushThisValue
		
		return move//, hisBestRtnMove, loopValue, captureScore, smallValScore,
			 				// dontGetHit,tTable2Value, retProtect, mhit, hhit, fwdVal,lsancValue,rsancValue,
							//  sancValue,getToMiddle,pushHimBack,mostMoved])

	//})		original foreach
		
		
		
		
		
		
		
		
		
		
		
		
		
		///////////////////////////////////////
		
		
		
		
		
		
		
		
		
		
		
		
	}
	function processSplitMove(data){
		
		//var result=[]
		var newData=[]
		
		while (data.length>0){
			
			newData.push(processMove(data.pop()))
		}
		
		
		return newData
	}

     $rootScope.doTask=function(task){
                 //where the magic happens
                
				 switch(task.command){
                     case "alert":
                        
                        // var tableForDB=0//make some dbtable
                        // console.log('evalGame received')
                        //sg like  evalGame(tableForDB)
						
						//!!!!!!!!!!!!
                      //this will stop the client!!  alert(task.message)
                        
                     break;   
					  case "refresh":
                        
						 console.log(task.message)
						 $rootScope.refreshWhenUp()
						 $rootScope.pollOn=false
                       
                        
                     break;   
					 
					 case "splitMove": 
					 
					 	var postThis=processSplitMove(task.data)
						 
						 $http.post('/myPartIsDone',postThis,function(req,res){
				
						})
						 
					 break;
					 
					 
					 case "move": 
					 	
						
						var postThis= dbAi(task.data)			///!!!! 
						 
						$http.post('/moved',postThis,function(req,res){
				
						})
					 
					 	// $rootScope.pleasePlay=false
					 
					 
					 break;
					 
					 case "evalGame":
					 	//console.log('t'+task.data.tableNum+' eval received')
						 var postThis=evaledGame(task.data)
						 console.log('tnum,pollnum,wwon,bwon,isdraw: ',postThis.tableNum,postThis.pollNum,postThis.whiteWon,postThis.blackWon,postThis.isDraw)
						 $http.post('/evaledGame',postThis,function(req,res){
							 $rootScope.sendMessage('t'+postThis.tableNum+' posted.')
						 })
						 //should ping
					break;
                     
                 }
                 
                 
             }
             
           
            /////////longpoll tasks stuff

            $rootScope.taskNum=0
               
                var longPollTasks=function(){
                    
                    $http.get('/longPollTasks?id='+$rootScope.sendID+'&tn='+$rootScope.taskNum+'&spd='+$rootScope.mySpeed)
                        .then(function(response){
                            
                            // 1 task received
                            
                            $rootScope.taskNum=response.data.taskNum
                            
                            $rootScope.receivedMessage=response.data.message        //display Heading
                            
                            $rootScope.sendMessage('task #'+response.data.taskNum+' received, '+response.data.command+': '+response.data.message)
                            
                            $rootScope.doTask(response.data)
                            
                            
                            if($rootScope.pollOn)longPollTasks()			//recall for new task, server will hold any new task until this one finishes
                    
                        },function(data){
                            //error, retry
                            $rootScope.receivedMessage='error'
                            $rootScope.refreshWhenUp()   //retry kene?
                        })
                    
                }

               
                 
              /////////longpoll tasks stuff end


    $rootScope.sendMessage = function(message) {
                $rootScope.messages.unshift(message + ' @' + (new Date).getTime())
            }

// all the crap here......


		$rootScope.heartBeat = 300
		$rootScope.mv = 0
		$rootScope.pw = false
		$rootScope.pollsPending = 0
		
		
		
			
	$rootScope.cookieID = ""
			//$rootScope.gotID=false

		function setCookie(cname, cvalue, exdays) {
			var d = new Date();
			d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
			var expires = "expires=" + d.toUTCString();
			document.cookie = cname + "=" + cvalue + "; " + expires;
		}

		function getCookie(cname) {
			var name = cname + "=";
			var ca = document.cookie.split(';');
			for(var i = 0; i < ca.length; i++) {
				var c = ca[i];
				while(c.charAt(0) == ' ') c = c.substring(1);
				if(c.indexOf(name) == 0) return c.substring(name.length, c.length);
			}
			return "";
		}

		$rootScope.cookieID = getCookie("myID");
		
		
		$rootScope.totalTook = getCookie("totalT2");
		$rootScope.moveCount = getCookie("mCount2");
		
		if($rootScope.moveCount =="")$rootScope.moveCount=0
		
		if($rootScope.cookieID==""){
		
			$rootScope.sendID=Math.random*100000000
		}else{
			$rootScope.sendID=$rootScope.cookieID
		}

		$rootScope.setID = function(id) {
			setCookie("myID", id, 365)
			$rootScope.cookieID = id //$rootScope.gotID=true
			$rootScope.sendID=id
		}	
		
		
		$rootScope.setCookies = function() {
			 setCookie("totalT2", $rootScope.totalTook, 365);
			 setCookie("mCount2", $rootScope.moveCount, 365);
		}
		
		
		longPollTasks()//start initial longpoll
	
	
	}
	appModule.controller("ApplicationController", ApplicationController);

	</script>
</head>

<body ng-app="appModule" ng-controller="ApplicationController">
	
	<form ng-if="cookieID==''" ng-submit="setID(thisID)">
		<input id="inputID" ng-model="thisID"></input>
	</form>
	
	
	<!--<p>Total moves: {{moveCount}}</p> 
	<p>Learner average: {{totalTook}} / {{moveCount}} = {{avgTime}} </p>-->
			
				
				
				
    

    <h3
		>{{receivedMessage}}
	</h>

	<p>
		Totals:
		{{totalTaskCount}} tasks done in {{totalTasksTime}} milliseconds.
		
		{{readyToPlay}}
		{{pleasePlay}}
		{{myGame.pollNum}}
		
	</p>

    <div style="font-size:10px" ng-repeat="x in messages">
		{{x}}
	</div>

				
				

</body>
